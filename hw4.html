<!DOCTYPE html>
<html>
<head>
<style>
#info {
	position: absolute;
	top: 0px;
	width: 100%;
	padding: 10px;
	text-align: center;
	color: #8b0000;
}

body {
	overflow: hidden;
}
</style>
</head>
<body>
<div id="info">
	<h1>Homework 4 - Class, Texture Animation, and Picking</h1>
</div>
<p id = 'msg'></p>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>


<script>
class Candles {

	constructor(positionX = 0, positionZ = 0){
	
		var candle = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 15, 32), new THREE.MeshPhongMaterial({
		color: 0xfa8072,
		}));
		candle.position.x = positionX;
		candle.position.y = 7.5;
		candle.position.z = positionZ;
		
		let loader = new THREE.TextureLoader();    // load a resource
		loader.load('https://i.imgur.com/sAQQugh.png',
			function(texture) {
				var texMat = new THREE.MeshBasicMaterial({
					map: texture,
					alphaTest:0.5
				});
				var flameMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), texMat);
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set (1/3,1/3);
				texture.offset.set (0,2/3);
				//scene.add (flameMesh);
				//this.candle = makeCandles(positionX, positionZ);
				candle.add(flameMesh);
				scene.add(candle);
				flameMesh.position.y = 11;
			},
			undefined,
			function(xhr) {
			  console.log('An error happened');
			}
		);
		
		this.light = new THREE.PointLight("white", 0.4);
		this.light.position.set(positionX, 22, positionZ);
		scene.add(this.light);
		
		return candle;
	}	
	
	textureAnimateClass() {
		console.log("1");
		textureAnimateClass.count = (textureAnimateClass.count === undefined) ? 1 : textureAnimateClass.count;

		if (flameMesh!== undefined) {
			var texture = this.flameMesh.material.map;
			texture.offset.x += 1/3;
			
			if (textureAnimateClass.count % 3 === 0) {
				texture.offset.y -= 1/3;
			}
			textureAnimateClass.count++;
		}
		return;
	}
	
	flameOut() {
		console.log("2");
		this.flameMesh.material.visible = false;
		return;
	}
	
	ignition() {
		console.log("3");
		flameMesh0.material.visible = true;
		return;
	}
}

var camera, scene, renderer;
var candle0, flameMesh0, light0;
var candlesGroup = [];

var raycaster;
var mouse = new THREE.Vector2();
var pickables = [];

init();
animate();

function makeCandles(positionX, positionZ) {

	var candle = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 15, 32), new THREE.MeshPhongMaterial({
		color: 0xfa8072,
	}));
	candle.position.x = positionX;
	candle.position.y = 7.5;
	candle.position.z = positionZ;
	return candle;
}

function CandleLight() {

	let loader = new THREE.TextureLoader();    // load a resource
  
	loader.load('https://i.imgur.com/sAQQugh.png',
		function(texture) {
			var texMat = new THREE.MeshBasicMaterial({
				map: texture,
				alphaTest:0.5
			});
			flameMesh0 = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), texMat);
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set (1/3,1/3);
			texture.offset.set (0,2/3);
			//scene.add (flameMesh);
			candle0 = makeCandles(0, 0);
			candle0.add (flameMesh0);
			scene.add (candle0);
			flameMesh0.position.y = 11;
		},
		undefined,
		function(xhr) {
		  console.log('An error happened');
		}
	  );

	light0 = new THREE.PointLight("white", 0.4);
	light0.position.set(0, 20, 0);
	scene.add(light0);
}

function textureAnimate() {

	textureAnimate.count = (textureAnimate.count === undefined) ? 1 : textureAnimate.count;

	if (flameMesh0!== undefined) {
		var texture = flameMesh0.material.map;
		texture.offset.x += 1/3;
		
		if (textureAnimate.count % 3 === 0) {
			texture.offset.y -= 1/3;
		}
		textureAnimate.count++;
	}
}

function init() {
	
	renderer = new THREE.WebGLRenderer();
	document.body.appendChild(renderer.domElement);
	var width = window.innerWidth;
	var height = window.innerHeight;
	renderer.setSize(width, height);

	renderer.setClearColor(0xe9967a);

	scene = new THREE.Scene();
	var grid = new THREE.GridHelper(200, 20, 'red', 'white');
	//scene.add(grid);
	var axes = new THREE.AxesHelper(5);
	//scene.add(axes);

	camera = new THREE.PerspectiveCamera(35, width / height, 1, 10000);
	camera.position.set(150, 100, 0);
	camera.lookAt(new THREE.Vector3(0, 10, 0));
	
	let controls = new THREE.OrbitControls(camera, renderer.domElement);
	
	controls.enableKeys = false;

	window.addEventListener('resize', onWindowResize, false);
	////////////////////////////////////////////////////////////////
	var ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({
		color: 0x8b0000
	}));
	ground.rotation.x = -Math.PI / 2;
	
	CandleLight();
	
	var candle1 = new Candles(-40, 40);
	var candle2 = new Candles(-40, 0);
	var candle3 = new Candles(-40, -40);
	var candle4 = new Candles(0, 40);
	var candle5 = new Candles(0, -40);
	candlesGroup.push(candle1, candle2, candle3, candle4, candle5);
	scene.add(ground);
	flameInterval = setInterval(textureAnimate, 70);
	candlesGroup.forEach(function(t){t.flameInterval = setInterval(t.textureAnimateClass, 70)});
	///////////////////////////////////////////////////////////////////////////
	
	raycaster = new THREE.Raycaster();
	document.addEventListener('pointerdown', onDocumentMouseDown, false);	///Trying///
	document.addEventListener('pointermove', onDocumentMouseOver, false);	///Trying///
}

function onDocumentMouseDown(event) {	///Trying///

  // PICKING DETAILS: 
  // convert mouse.xy = [-1,1]^2 (NDC)
  // unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
  // set raycaster (origin, direction)
  // find intersection objects, (closest first) 
  // each record as
  // [ { distance, point, face, faceIndex, object }, ... ]

	//  event.preventDefault();  // may not be necessary
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables, true);
  if (intersects.length > 0) {
		$('#msg').text ('you have picked ' + '"' + intersects[0].object.name + '"')
	} else {
  	$('#msg').text ('nothing picked')
  }
}

function onDocumentMouseOver(event) {	///Trying///

	event.preventDefault();  // may not be necessary
	mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
	raycaster.setFromCamera(mouse, camera);
	var intersects = raycaster.intersectObjects(pickables, true);
	if (intersects.length > 0) {
		document.body.style.cursor = 'pointer';
	} else {
		document.body.style.cursor = 'auto';
	}
}

function onWindowResize() {

	var width = window.innerWidth;
	var height = window.innerHeight;
	camera.aspect = width / height;
	camera.updateProjectionMatrix();
	renderer.setSize(width, height);
}

function update(evt) {	///Testimg///

	if (evt.key == 5) {

		flameMesh0.material.visible = false;
		light0.intensity = 0;
		setTimeout(function() {
			flameMesh0.material.visible = true;
			light0.intensity = 0.4;
		}, 2500);
	}
}

function animate() {
	
	window.onkeydown = function(evt){
		var evt = window.event?window.event:evt;
		update(evt);
	}
	
	requestAnimationFrame(animate);
	render();
	
	let cameraRoot = camera.position.clone();
    cameraRoot.y = 0;
	if (candle0 !== undefined)
		candle0.lookAt(cameraRoot);
	candlesGroup.forEach(function(t){t.lookAt(cameraRoot)});
}

function render() {

	renderer.render(scene, camera);
}
</script>

</body>
</html>